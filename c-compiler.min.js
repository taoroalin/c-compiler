regex = /(?<float>[0-9]+\.[0-9]+)|(?<int>[0-9]+)|(?<string>"(?:[^"]|\")*")|(?<char>'(?:[^']|\')*')|(?<label>\n[a-zA-Z0-9_]+:)|(?<directive>#[a-zA-Z0-9_]+)|(?<name>[a-zA-Z_][a-zA-Z0-9_]*)|(?<linecomment>\/\/[^\n]*\n)|(?<blockcomment>\/\*(?:[^*]|\*[^/])*\*\/)|(?<whitespace>\s+)|\-|\.|&|\||!|\||&|>|<|\^|~|\+|\-|\+|\-|\*|\/|%|=|!|>|<|>|<|=|;|,|\(|\)|\[|\]|\{|\}/gs; lexC = (e => { const t = { for: 1, while: 1, do: 1, break: 1, continue: 1, if: 1, else: 1, switch: 1, case: 1, default: 1, goto: 1, typedef: 1, struct: 1, union: 1, sizeof: 1, void: 1, return: 1, register: 1, auto: 1, volatile: 1, static: 1, extern: 1, const: 1, unsigned: 1, int: 1, short: 1, long: 1, double: 1, float: 1, char: 1 }, n = { define: 1, include: 1, undef: 1, ifdef: 1, ifndef: 1, if: 1, else: 1, elif: 1, endif: 1, error: 1, pragma: 1 }; let o = 0; console.log("lexing: " + e); const r = []; for (let i of e.matchAll(regex)) { if (i.index != o) throw new SyntaxError(`Can't lex ${e.substring(o, i.index)} at position ${o}`); const s = i[0]; if (i.groups.whitespace || i.groups.linecomment || i.groups.blockcomment) { o = i.index + s.length; continue } const a = { text: s }; if (i.groups.directive && !n[s.substring(1)]) throw new SyntaxError(`Can't lex # directive ${s.substring(1)}`); i.groups.name && (t[s] ? a.keyword = s : a.name = s), i.groups.string && (a.string = s.substring(1, s.length - 1)), i.groups.char && (a.char = s.substring(1, s.length - 1)), i.groups.int && (a.int = parseInt(s)), i.groups.float && (a.float = parseFloat(s)), r.push(a), o = i.index + s.length } if (o != e.length) throw new SyntaxError(`Can't lex ${e.substring(o)} at position ${o}`); return r.push({ end: !0 }), console.log(r), r }), parseC = (e => { const t = lexC(e); let n = 0; const o = e => { const t = n, o = e(); if (o) return o; n = t }, r = () => { const e = t[n]; return n++, e }, i = (...e) => { const t = n; for (let o of e) { const e = o(); if (e) return e; n = t } }, s = () => { if ("{" !== r().text) return; const e = o(a); return void 0 !== e && "}" === r().text ? e : void 0 }, a = () => { const e = { astType: "statements", statements: [] }; for (; ;) { const t = o(p); if (!t) break; e.statements.push(t) } if (e.statements.length > 0) return e }, p = () => i(b, x, d, c), c = () => { const e = { astType: "expressionStatement", expression: void 0 }; if (e.expression = o(m), ";" === r().text) return e }, d = () => i(l, g, y, u, f, s), l = () => { const e = { astType: "while", condition: void 0, body: void 0 }; if ("while" === r().keyword && "(" === r().text && (e.condition = o(m), e.condition && ")" === r().text && (e.body = o(s), void 0 !== e.body))) return e }, y = () => { const e = { astType: "for", setup: void 0, condition: void 0, increment: void 0, body: void 0 }; if ("for" === r().keyword && "(" === r().text && (e.setup = o(p), e.setup && (e.condition = o(p), e.condition && (e.increment = o(m), e.increment && ")" === r().text && (e.body = o(s), e.body))))) return e }, u = () => { if ("if" !== r().keyword) return; if ("(" !== r().text) return; const e = { astType: "while", condition: void 0, body: void 0 }; return e.condition = o(m), e.condition && ")" === r().text && (e.body = o(s), void 0 !== e.body) ? e : void 0 }, f = () => { const e = { astType: "doWhile", condition: void 0, body: void 0 }; if ("do" === r().keyword && (e.body = o(s), void 0 !== e.body && "while" === r().keyword && "(" === r().text && (e.condition = o(m), e.condition && ")" === r().text && ";" === r().text))) return e }, g = () => { const e = { astType: void 0, gotoLabel: void 0 }; switch (t[n].keyword) { case "break": n++, node.astType = "break"; break; case "continue": n++, node.astType = "continue"; break; case "goto": if (!t[++n].name) return; node.astType = "goto", node.gotoLabel = t[n].name, n++; break; case "return": if (n++, node.expression = o(m), void 0 !== node.expression) return; break; default: return }if (";" === t[n].text) return n++, e }, x = () => { const e = { astType: "functionDeclaration", returnType: void 0, name: void 0, arguments: [], body: void 0 }; if (e.returnType = o(T), e.returnType && (e.name = r().name, e.name)) { if (")" === t[n].text) n++; else for (let t = 0; "end" !== t;) { const n = o(T); if (!n) return; const i = r().name; if (!i) return; switch (e.parameters.push({ type: n, name: i }), r().text) { case ")": t = "end"; break; case ",": break; default: return } } e.body = o(s), e.body } }, b = () => { const e = { astType: "declaration", type: void 0, name: void 0, expression: void 0 }; if (e.type = o(T), e.type && (e.name = r().name, e.name && "=" === r().text && (e.expression = o(m), e.expression && ";" === r().text))) return e }, T = () => { const e = { astType: "type", typeTag: void 0 }, o = t[n]; if (o.keyword) { switch (o.keyword) { case "int": e.typeTag = "int", n++; break; case "float": e.typeTag = "float", n++; break; default: return }return e } }, m = () => i(h, w, k, v, C), v = () => { const e = r().name; if (void 0 !== e) return { astType: "variable", name: e } }, h = () => { let e = r(); if (void 0 !== e.int) { return { astType: "expression", expressionType: "literal", type: { astType: "type", typeTag: "int", size: 32, unsigned: !1 }, value: e.int } } if (void 0 !== e.float) { return { astType: "expression", expressionType: "literal", type: { astType: "type", typeTag: "float", size: 64 }, value: e.float } } if (void 0 !== e.char) { return { astType: "expression", expressionType: "literal", type: { astType: "type", typeTag: "char", size: e.char.length }, value: e.char } } if (void 0 !== e.string) { return { astType: "expression", expressionType: "literal", type: { astType: "type", typeTag: "string", size: e.string.length + 1 }, value: e.string } } }, w = () => { }, k = () => { const e = { astType: "application", name: void 0, parameters: [] }; if (e.name = r().name, e.name && "(" === r().text) { if (")" === t[n].text) return n++, e; for (let t = 0; "end" !== t;) { const n = o(m); if (!n) return; switch (e.parameters.push(n), r().text) { case ")": t = "end"; break; case ",": break; default: return } } return e } }, C = () => { if ("(" !== t[n].text) return; n++; const e = o(m); return void 0 !== e && ")" === t[n].text ? (n++, e) : void 0 }; return o(a) }); const defaultTypes = { s64: { typeTag: "int", size: 64, unsigned: !1 }, s32: { typeTag: "int", size: 32, unsigned: !1 }, f32: { typeTag: "float", size: 32 }, f64: { typeTag: "float", size: 64 } }, _astTypes = "expression statements statement declaration type while for if ", _expressionTypes = "literal operatorExpression application"; typecheckC = (e => { const t = { structs: {}, types: defaultTypes, functions: {}, globals: {}, main: void 0 }; let n = "$GLOBAL$"; const o = e => { switch (console.log(e), e.astType) { case "declaration": const r = { type: o(e.type), expression: o(e.expression) }, i = e.name; if ("$GLOBAL$" === n) { if (t.globals[i]) throw new Error(`Redeclaration of global variable ${i}`); r.parent = t.globals[i], t.globals[i] = r } else { const e = t.functions[n]; if (e.variables[i]) throw new Error(`Redeclaration of function scope variable ${i}`); e.variables[i] = r, r.parent = e } break; case "expression": e.expressionType; break; case "type": break; case "statements": case "while": case "for": case "goto": (e => { for (let t of e.statements || []) o(t); e.body && o(e.body), e.condition && o(e.condition), e.setup && o(e.setup), e.comparison && o(e.comparison), e.increment && o(e.increment) })(e); break; default: throw new Error(`astType not recognized by typechecker: ${e.astType}`) } }; return o(e), t }), generateBinary = (e => { }), parseAndTypecheck = (e => { const t = parseC(e); return typecheckC(t) }), compileC = (e => { const t = parseC(e), n = typecheckC(t); return generateBinary(n) }), interpretTypedAst = (e => { });